<template>
    <div class="mt-2">
        <div v-if="data.start.length">
            Started with:
            <ul>
                <li v-for="initial in data.start">
                    {{initial.name}} <img class="icon" :alt="initial.name" :data-original-title="initial.description"
                        :src="initial.icon">
                    {{initial.stack > 1 ? "("+initial.stack+")" : ""}} ({{round3(initial.duration)}}
                    seconds remaining)
                </li>
            </ul>
        </div>
        <div v-if="data.refreshed.length">
            In phase consumable updates:
            <ul>
                <li v-for="refresh in data.refreshed">
                    {{refresh.dimished ? 'suffered' : 'consumed'}} {{refresh.name}}
                    <img class="icon" :alt="refresh.name" :data-original-title="refresh.description"
                        :src="refresh.icon">
                    {{refresh.stack > 1 ? "("+refresh.stack+")" : ""}}
                    at {{round3(refresh.time)}}s ({{round3(refresh.duration)}}
                    seconds)
                </li>
            </ul>
        </div>
        <div v-if="!data.refreshed.length && !data.start.length" class="text-center">
            <h3>No consumable activity</h3>
        </div>
    </div>
</template>

<script>
    Vue.component("food-component", {
        props: ["phaseindex", "playerindex"],
        template: `${template}`,
        data: function () {
            return {
                cache: new Map()
            };
        },
        mixins: [numberComponent],
        computed: {
            phase: function () {
                return logData.phases[this.phaseindex];
            },
            food: function () {
                return logData.players[this.playerindex].details.food;
            },
            data: function () {
                if (this.cache.has(this.phase)) {
                    return this.cache.get(this.phase);
                }
                const res = {
                    start: [],
                    refreshed: []
                };

                const encounteredStartIDs = new Set();
                const encounteredStartUniqueSlots = new Set();

                for (let k = this.food.length - 1; k >= 0; k--) {
                    const foodData = this.food[k];
                    if (!foodData.name) {
                        var skill = findSkill(true, foodData.id);
                        foodData.name = skill.name;
                        foodData.icon = skill.icon;
                        foodData.description = skill.description;
                    }
                    let phaseFood = {};
                    Object.assign(phaseFood, foodData);
                    if (phaseFood.time <= this.phase.start && phaseFood.time + phaseFood.duration >= this.phase.start) {
                        if (encounteredStartIDs.has(foodData.id)) {
                            continue;
                        }
                        if (foodData.uniqueSlot > 0 && encounteredStartUniqueSlots.has(foodData.uniqueSlot)) {
                            continue;
                        }
                        encounteredStartIDs.add(foodData.id);
                        encounteredStartUniqueSlots.add(foodData.uniqueSlot);
                        phaseFood.duration -= (this.phase.start - phaseFood.time);
                        phaseFood.time = this.phase.start;
                        res.start.push(phaseFood);
                    } else if (phaseFood.time >= this.phase.start && phaseFood.time <= this.phase.end) {
                        phaseFood.time -= this.phase.start;
                        res.refreshed.push(phaseFood);
                    }
                }
                res.start.sort((x,y) => x.time - y.time);
                res.refreshed.sort((x,y) => x.time - y.time);
                this.cache.set(this.phase, res);
                return res;
            }
        }
    });
</script>
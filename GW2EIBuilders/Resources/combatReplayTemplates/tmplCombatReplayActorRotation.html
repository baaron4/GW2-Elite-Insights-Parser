<template>
    <div class="d-flex align-items-center actor-rotation">
        <div v-if="rotation.current">
            <img class="icon-ll" :class="getIconClass(rotation.current)" :src="rotation.current.skill.icon" :title="getTooltip(rotation.current)"/>
        </div>
        <div v-else class="empty-icon-ll">

        </div>
        <div v-for="next in rotation.nexts">
            <img class="icon-l" :class="getIconClass(next)" :src="next.skill.icon" :title="getTooltip(next)"/>
        </div>
    </div>
</template>

<script>
    
    Vue.component("combat-replay-actor-rotation-component", {
        mixins: [timeRefreshComponent],
        props: ["actorindex", "enemy"],
        template: `${template}`,
        methods: {
            getSkillDuration: function(item) {
                return Math.max(item[2], 1) * 1e-3;
            },
            findRotationIndex: function (rotation, timeS, start, end) {
                if (end === 0) {
                    return 0;
                }
                if (timeS < rotation[start][0]) {
                    return start;
                } else if (timeS > rotation[end][0] + this.getSkillDuration(rotation[end])) {
                    return end;
                }
                const id = Math.floor((end + start) / 2);
                if (id === start || id === end) {
                    const item = rotation[start];
                    const x = item[0];
                    const duration = this.getSkillDuration(item);
                    if (timeS >= x && x + duration >= timeS) {
                        return start;
                    }
                    return end;
                }
                const item = rotation[id];
                const x = item[0];
                const duration = this.getSkillDuration(item);
                if (timeS < x) {
                    return this.findRotationIndex(rotation, timeS, start, id);
                } else if (timeS > x + duration) {
                    return this.findRotationIndex(rotation, timeS, id, end);
                } else {
                    return id;
                }
            },
            getIconClass(cast) {
                return {
                    'rot-cancelled': cast.type === RotationStatus.CANCEL,
                    'rot-unknown': cast.type === RotationStatus.UNKNOWN,
                    'rot-animfull': cast.type === RotationStatus.FULL,
                    'rot-instant': cast.type === RotationStatus.INSTANT
                };
            },
            getTooltip(cast) {
                const tooltip = `${cast.skill.name} at ${cast.time}s`;
                if (cast.type === RotationStatus.INSTANT) {
                    return tooltip;
                } else {
                    return tooltip + ` for ${cast.duration}ms`;
                }
            }
        },
        computed: {
            actor: function () {
                return this.enemy ? logData.targets[this.actorindex] : logData.players[this.actorindex];
            },
            actorRotation: function () {
                return this.actor.details.rotation[0];
            },
            actorSplitRotation: function () {
                const actorNoInstantRotation = [];
                const actorNoInstantRotationIndex = [];
                const actorInstantRotation = [];
                const actorInstantRotationIndex = [];
                for (let i = 0; i < this.actorRotation.length; i++) {
                    const rot = this.actorRotation[i];
                    if (rot[3] !== RotationStatus.INSTANT) {
                        actorNoInstantRotation.push(rot);
                        actorNoInstantRotationIndex.push(i);
                    } else {
                        actorInstantRotation.push(rot);
                        actorInstantRotationIndex.push(i);
                    }
                }
                return [actorNoInstantRotation, actorNoInstantRotationIndex, actorInstantRotation, actorInstantRotationIndex];
            },
            rotation: function () {
                const res = {
                    current: null,
                    nexts: []
                };
                if (this.actorRotation.length === 0) {
                    return res;
                }
                const time = this.timeToUse / 1000.0;
                const [actorNoInstantRotation, actorNoInstantRotationIndex, actorInstantRotation, actorInstantRotationIndex] = this.actorSplitRotation;
                let idInstant = -1;
                let instantItem = null;
                if (actorInstantRotation.length > 0) {
                    let idInInstant = this.findRotationIndex(actorInstantRotation, time, 0, actorInstantRotation.length - 1);
                    idInstant = actorInstantRotationIndex[idInInstant];
                    instantItem = actorInstantRotation[idInInstant];
                }
                let idNoInstant = -1;
                let noInstantItem = null;
                if (actorNoInstantRotation.length > 0) {
                    let idInNoInstant = this.findRotationIndex(actorNoInstantRotation, time, 0, actorNoInstantRotation.length - 1);
                    idNoInstant = actorNoInstantRotationIndex[idInNoInstant];
                    noInstantItem = actorNoInstantRotation[idInNoInstant];
                }
                let item = noInstantItem;
                let id = idNoInstant;
                if (instantItem) {
                    if (!item ||
                        item[0] > instantItem[0] ||
                        (instantItem[0] <= time &&
                        time <= instantItem[0] + this.getSkillDuration(instantItem))
                    ) {
                        item = instantItem;
                        id = idInstant;
                    }
                }
                const itemTime = item[0];
                let drawItem = false;
                if (itemTime <= time && time <= itemTime + this.getSkillDuration(item)) {
                    drawItem = true;
                }
                if (drawItem) {
                    res.current = {
                        time: itemTime,
                        skill: findSkill(false, item[1]),
                        duration: item[2],
                        type: item[3]
                    };
                    id++;
                }
                for (let j = id; j < this.actorRotation.length; j++) {
                    const next = this.actorRotation[j];
                    if (next[0] >= time) {
                        res.nexts.push({
                            time: next[0],
                            skill: findSkill(false, next[1]),
                            duration: next[2],
                            type: next[3]
                        });
                    }
                    if (res.nexts.length == 4) {
                        break;
                    }
                }
                return res;
            },
        }
    });
</script>

<template>
    <div class="d-flex flex-column justify-content-center flex-wrap" :style="{'width': Math.max(canvas.x, canvas.y) + 'px'}">
        <div class="d-flex flex-column justify-content-center align-items-center" :style="{'width': '100%', 'min-width': canvas.x + 'px', 'height': canvas.y + 'px', 'position': 'relative'}">
            <canvas :width="canvas.x + 'px'" :height="canvas.y + 'px'" id="main-canvas" class="replay"></canvas>
            <canvas :width="canvas.x + 'px'" :height="canvas.y + 'px'" id="bg-canvas" class="replay"></canvas>
        </div>
        <div class="animation-control">
            <div class="d-flex justify-content-center">
                <div @click="toggleAnimate();"
                     class="btn btn-small" :class="{'btn-dark': !light, 'btn-light': light}" style="width: 50px;">{{animated ? "Pause" : "Play"}}</div>
                <div @click="restartAnimate();" class="btn btn-small" :class="{'btn-dark': !light, 'btn-light': light}">
                    Restart
                </div>
                <div @click="toggleBackwards();"
                     class="btn btn-small" :class="{'active': backwards, 'btn-dark': !light, 'btn-light': light}">Backwards</div>
            </div>
                <div class="d-flex flex-row flex-wrap justify-content-center mt-1 mb-1">
                    <div class="btn btn-ssmall" :class="{'active': backwards, 'btn-dark': !light, 'btn-light': light}"
                        v-for="phase in phases" @click="updatePhaseTime(phase.start * 1000, phase.end * 1000, phase.name)"
                        :data-original-title="phase.durationS + ' seconds'">
                        {{phase.name}}
                    </div>
                </div>
            <div class="d-flex justify-content-center slidecontainer">
                <input style="min-width: 400px;" @input="updateTime($event.target.value)" type="range" min="0"
                       :max="maxTime" value="0" class="slider" id="timeRange" :style="{'background': getSliderGradient()}">
                <p style="position: absolute; color: black;">{{sliderDelimiter.name}}</p>
                <input style="width: 70px; text-align: right;" class="ml-3 mr-1" type="text" id="timeRangeDisplay" value="0"
                       @input="updateInputTime($event.target.value);">
            </div>
            <div class="d-flex justify-content-center">
                <label v-for="speed in speeds" @click="setSpeed(speed)" :class="{'active': speed === selectedSpeed, 'btn-dark': !light, 'btn-light': light}"
                       class="btn btn-ssmall">
                    {{speed}}x
                </label>
            </div>
            <p class="text-justify text-center">Double click on canvas to restore viewpoint</p>
        </div>
    </div>
</template>

<script>
    Vue.component("combat-replay-animation-control-component", {
        props: ["light", "animated"],
        template: `${template}`,
        data: function () {
            return {
                speeds: [0.125, 0.25, 0.5, 1.0, 2.0, 4.0, 8.0, 16.0],
                selectedSpeed: 1,
                backwards: false,
                canvas: {
                    x: logData.crData.sizes[0],
                    y: logData.crData.sizes[1]
                },
                maxTime: logData.crData.maxTime,
                sliderDelimiter: sliderDelimiter
            };
        },
        computed: {
            phases: function() {
                return logData.phases.filter(phase => !phase.breakbarPhase);
            }
        },
        methods: {
            getSliderGradient: function () {
                var startPercent, endPercent;
                if (!this.sliderDelimiter || this.sliderDelimiter.min === -1) {
                    startPercent = 0;
                    endPercent = 100;
                } else {
                    var max = animator.times[animator.times.length - 1];
                    startPercent = this.sliderDelimiter.min / max * 100;
                    endPercent = this.sliderDelimiter.max / max * 100;
                }
                return computeSliderGradient("#888888", "#F3F3F3", startPercent, endPercent);
            },
            toggleBackwards: function () {
                this.backwards = animator.toggleBackwards();
            },
            toggleAnimate: function () {
                animator.toggleAnimate();
            },
            restartAnimate: function () {
                animator.restartAnimate();
            },
            setSpeed: function (speed) {
                animator.setSpeed(speed);
                this.selectedSpeed = speed;
            },
            updateTime: function (value) {
                animator.updateTime(value);
            },
            updatePhaseTime: function (min, max, name) {
                this.updateTime(min);
                this.sliderDelimiter.min = min;
                this.sliderDelimiter.max = max;
                this.sliderDelimiter.name = name;
            },
            updateInputTime: function (value) {
                animator.updateInputTime(value);
            }
        },
    });
</script>
